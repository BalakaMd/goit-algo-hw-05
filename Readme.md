# EX_1 - Хеш-Таблиця

## Опис
Цей клас реалізує просту хеш-таблицю з використанням методу ланцюжків для вирішення колізій. Хеш-таблиця дозволяє вставляти, отримувати та видаляти елементи за ключем.

## Методи
- `__init__(self, size)`: Конструктор, який ініціалізує хеш-таблицю зазначеного розміру.
- `hash_function(self, key)`: Функція хешування, яка обчислює хеш для ключа.
- `insert(self, key, value)`: Вставляє пару ключ-значення в хеш-таблицю.
- `get(self, key)`: Повертає значення за ключем, якщо воно існує.
- `delete(self, key)`: Видаляє пару ключ-значення з хеш-таблиці за ключем.

## Приклад використання
```python
H = HashTable(5)
H.insert("apple", 10)
H.insert("orange", 20)
H.insert("banana", 30)

print(H.get("apple"))  # Виведе: 10
print(H.get("orange"))  # Виведе: 20
print(H.get("banana"))  # Виведе: 30

H.delete("apple")
print(H.get("apple"))  # Виведе: None
```
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------


# EX_2 - Бінарний Пошук для Дійсних Чисел

## Опис
Цей файл містить реалізацію бінарного пошуку для масиву дійсних чисел. Функція `binary_search_float` 
здійснює пошук елемента в масиві і повертає кількість ітерацій, необхідних для пошуку, та найближчий елемент зверху, якщо точний елемент не знайдено.

## Методи
- `binary_search_float(arr, x)`: Функція приймає масив `arr` та шуканий елемент `x`, повертає кортеж з кількості
- ітерацій та елемента.

## Приклад використання
```python
arr_float = [1.5, 2.5, 3.5, 4.5, 5.5, 6.5]
x_float = 4.0
iterations, upper_bound = binary_search_float(arr_float, x_float)

if upper_bound is not None:
    print(f"Елемент {x_float} знаходиться за індексом {arr_float.index(upper_bound)}")
    print(f"Верхня межа: {upper_bound}")
else:
    print(f"Елемент {x_float} не знайдено в масиві.")
    print(f"Верхня межа: {arr_float[-1]}")
```
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
# EX_3 - Аналіз Ефективності Алгоритмів Пошуку Підрядка

## Вступ
Цей файл містить порівняльний аналіз трьох алгоритмів пошуку підрядка: Кнута-Морріса-Пратта, Рабіна-Карпа та 
Бойера-Мура. Аналіз базується на вимірюванні часу виконання кожного алгоритму на двох різних текстах.

## Методологія
Для кожного алгоритму було виміряно час пошуку підрядка в тексті. Вимірювання проводились на двох текстах 
(Стаття 1 та Стаття 2) з різними розмірами. Кожен алгоритм було виконано 10 разів для отримання середнього часу виконання.

## Результати

### Стаття 1.txt
- Розмір тексту: 12646 символів.
- Розмір підрядка: 33 символи.
- Кількість повторень: 10.

| Алгоритм | Час пошуку (секунди) |
|----------|----------------------|
| Кнута    | 0.01123              |
| Рабіна-Карпа | 0.0234            |
| Бойера-Мура | **0.00153**        |

### Стаття 2.txt
- Розмір тексту: 18438 символів.
- Розмір підрядка: 28 символів.
- Кількість повторень: 10.

| Алгоритм | Час пошуку (секунди) |
|----------|----------------------|
| Кнута    | 0.01129              |
| Рабіна-Карпа | 0.02698            |
| Бойера-Мура | **0.00211**        |

## Висновки
Алгоритм пошуку Бойера-Мура продемонстрував найкращу ефективність у обох випадках, показавши найменший час виконання.
Це робить його найкращим вибором для пошуку підрядка в цих конкретних текстах. 
